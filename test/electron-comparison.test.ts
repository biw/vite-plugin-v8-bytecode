import { describe, it, expect, beforeAll } from "vitest";
import { spawn } from "node:child_process";
import { compileToBytecode } from "../src/compiler";
import vm from "node:vm";
import fs from "node:fs";
import path from "node:path";
import os from "node:os";

/**
 * These tests compare bytecode generated by Node.js vs Electron
 * to determine if Electron-specific compilation is necessary
 */
describe("Node.js vs Electron Bytecode Comparison", () => {
  let electronPath: string | null = null;
  let hasElectron = false;

  beforeAll(async () => {
    // Try to find Electron in node_modules
    try {
      electronPath = require.resolve("electron");
      // The electron package exports the path to the executable
      // eslint-disable-next-line @typescript-eslint/no-require-imports
      const electronPackage = require("electron");
      if (
        typeof electronPackage === "string" &&
        fs.existsSync(electronPackage)
      ) {
        electronPath = electronPackage;
        hasElectron = true;
      }
    } catch (err: unknown) {
      console.error(err);
      expect(false).toBe(true);
      throw new Error("Electron not found");
    }
  });

  /**
   * Compiles JavaScript code using Electron as the Node runtime
   * Similar to Bytenode's compileElectronCode function
   */
  async function compileWithElectron(code: string): Promise<Buffer> {
    if (!electronPath || !hasElectron) {
      throw new Error("Electron not available");
    }

    return new Promise((resolve, reject) => {
      let data = Buffer.from([]);

      // We need to create a temporary script that compiles the code
      // because Electron needs to run our compilation code
      const tempDir = fs.mkdtempSync(
        path.join(os.tmpdir(), "electron-compile-")
      );
      const scriptPath = path.join(tempDir, "compile.js");

      // This script will be run by Electron
      const compileScript = `
const vm = require("vm");
const v8 = require("v8");

// Set V8 flags for eager compilation
try {
  v8.setFlagsFromString("--no-lazy");
  v8.setFlagsFromString("--no-flush-bytecode");
} catch (e) {
  console.error("Warning: Could not set V8 flags:", e);
}

// Read code from stdin
let inputCode = "";
process.stdin.on("data", (chunk) => {
  inputCode += chunk.toString();
});

process.stdin.on("end", () => {
  try {
    // Wrap in module wrapper
    const wrappedCode = \`(function (exports, require, module, __filename, __dirname) { \${inputCode}\\n});\`;
    
    // Compile to bytecode
    const script = new vm.Script(wrappedCode, {
      produceCachedData: true,
    });

    if (!script.cachedData) {
      console.error("Failed to generate bytecode");
      process.exit(1);
    }

    // Write bytecode to stdout
    process.stdout.write(script.cachedData);
  } catch (error) {
    console.error("Compilation error:", error);
    process.exit(1);
  }
});
`;

      fs.writeFileSync(scriptPath, compileScript);

      // Spawn Electron with ELECTRON_RUN_AS_NODE to use it as Node.js
      const child = spawn(electronPath!, [scriptPath], {
        env: { ...process.env, ELECTRON_RUN_AS_NODE: "1" },
        stdio: ["pipe", "pipe", "pipe"],
      });

      if (child.stdin) {
        child.stdin.write(code);
        child.stdin.end();
      }

      if (child.stdout) {
        child.stdout.on("data", (chunk) => {
          data = Buffer.concat([data, chunk]);
        });
      }

      let stderrOutput = "";
      if (child.stderr) {
        child.stderr.on("data", (chunk) => {
          stderrOutput += chunk.toString();
        });
      }

      child.on("error", (err) => {
        fs.rmSync(tempDir, { recursive: true, force: true });
        reject(err);
      });

      child.on("exit", (code) => {
        fs.rmSync(tempDir, { recursive: true, force: true });

        if (code !== 0) {
          reject(
            new Error(
              `Electron compilation failed with code ${code}\nStderr: ${stderrOutput}`
            )
          );
        } else if (data.length === 0) {
          reject(new Error("No bytecode generated"));
        } else {
          resolve(data);
        }
      });
    });
  }

  /**
   * Helper to load and execute bytecode
   */
  function loadBytecode(bytecode: Buffer, testName: string): any {
    // Calculate dummy code length
    const sourceHash = bytecode.readUInt32LE(8);
    let dummyCode = "";
    if (sourceHash > 1) {
      dummyCode = '"' + "\u200b".repeat(sourceHash - 2) + '"';
    }

    // Create script with cached data
    const script = new vm.Script(dummyCode, {
      cachedData: bytecode,
    });

    if (script.cachedDataRejected) {
      throw new Error(`${testName}: Bytecode rejected`);
    }

    // Execute the wrapper function
    const compiledWrapper = script.runInThisContext();
    const mockModule = { exports: {} as any };
    compiledWrapper(
      mockModule.exports,
      require,
      mockModule,
      __filename,
      __dirname
    );

    return mockModule.exports;
  }

  it("should generate bytecode with Node.js", () => {
    const testCode = `
"use strict";
function greet(name) {
  return "Hello, " + name + "!";
}
module.exports = { greet };
`;

    const bytecode = compileToBytecode(testCode);

    expect(bytecode).toBeInstanceOf(Buffer);
    expect(bytecode.length).toBeGreaterThan(0);

    // Test that it executes
    const result = loadBytecode(bytecode, "Node.js");
    expect(result.greet).toBeDefined();
    expect(result.greet("Test")).toBe("Hello, Test!");
  });

  it("should generate bytecode with Electron (if available)", async () => {
    if (!hasElectron) {
      console.log("‚è≠Ô∏è  Skipping - Electron not installed");
      return;
    }

    const testCode = `
"use strict";
function greet(name) {
  return "Hello, " + name + "!";
}
module.exports = { greet };
`;

    const bytecode = await compileWithElectron(testCode);

    expect(bytecode).toBeInstanceOf(Buffer);
    expect(bytecode.length).toBeGreaterThan(0);

    // Test that it executes in Node.js
    const result = loadBytecode(bytecode, "Electron");
    expect(result.greet).toBeDefined();
    expect(result.greet("Test")).toBe("Hello, Test!");
  });

  it("should compare Node.js vs Electron bytecode structure", async () => {
    if (!hasElectron) {
      console.log("‚è≠Ô∏è  Skipping - Electron not installed");
      return;
    }

    const testCode = `
"use strict";
const value = 42;
function test() {
  return value * 2;
}
module.exports = { test, value };
`;

    const nodeBytecode = compileToBytecode(testCode);
    const electronBytecode = await compileWithElectron(testCode);

    console.log("\nüìä Bytecode Comparison:");
    console.log(`   Node.js size: ${nodeBytecode.length} bytes`);
    console.log(`   Electron size: ${electronBytecode.length} bytes`);
    console.log(
      `   Size difference: ${Math.abs(
        nodeBytecode.length - electronBytecode.length
      )} bytes`
    );

    // Compare bytecode structure
    // First 8 bytes are usually the same (magic number, etc.)
    const nodeHeader = nodeBytecode.subarray(0, 16);
    const electronHeader = electronBytecode.subarray(0, 16);

    console.log(`   Node.js header: ${nodeHeader.toString("hex")}`);
    console.log(`   Electron header: ${electronHeader.toString("hex")}`);

    // Test both execute correctly
    const nodeResult = loadBytecode(nodeBytecode, "Node.js");
    const electronResult = loadBytecode(electronBytecode, "Electron");

    expect(nodeResult.test()).toBe(84);
    expect(electronResult.test()).toBe(84);
    expect(nodeResult.value).toBe(42);
    expect(electronResult.value).toBe(42);
  });

  it("should test cross-compatibility (Node bytecode in Electron context)", async () => {
    if (!hasElectron) {
      console.log("‚è≠Ô∏è  Skipping - Electron not installed");
      return;
    }

    const testCode = `
"use strict";
function add(a, b) {
  return a + b;
}
module.exports = { add, result: add(5, 10) };
`;

    // Generate bytecode with Node.js
    const nodeBytecode = compileToBytecode(testCode);

    // Try to load it in Node.js (should work)
    const nodeResult = loadBytecode(nodeBytecode, "Node.js");
    expect(nodeResult.result).toBe(15);
    expect(nodeResult.add(2, 3)).toBe(5);

    console.log("‚úÖ Node.js bytecode works in Node.js");
    console.log(
      "‚ö†Ô∏è  Cross-compatibility with Electron would require Electron runtime tests"
    );
  });

  it("should test template literals in Node vs Electron", async () => {
    if (!hasElectron) {
      console.log("‚è≠Ô∏è  Skipping - Electron not installed");
      return;
    }

    // This code has template literals (which we transform)
    const testCode = `
"use strict";
function greet(name) {
  return "Hello, " + name + "!";  // Already transformed
}
module.exports = { greet };
`;

    const nodeBytecode = compileToBytecode(testCode);
    const electronBytecode = await compileWithElectron(testCode);

    // Both should execute successfully
    const nodeResult = loadBytecode(nodeBytecode, "Node.js");
    const electronResult = loadBytecode(electronBytecode, "Electron");

    expect(nodeResult.greet("Node")).toBe("Hello, Node!");
    expect(electronResult.greet("Electron")).toBe("Hello, Electron!");
  });

  it("should test arrow functions in Node vs Electron", async () => {
    if (!hasElectron) {
      console.log("‚è≠Ô∏è  Skipping - Electron not installed");
      return;
    }

    const testCode = `
"use strict";
const multiply = (a, b) => a * b;
module.exports = { multiply, result: multiply(6, 7) };
`;

    const nodeBytecode = compileToBytecode(testCode);
    const electronBytecode = await compileWithElectron(testCode);

    // Both should execute successfully (thanks to --no-lazy flag)
    const nodeResult = loadBytecode(nodeBytecode, "Node.js");
    const electronResult = loadBytecode(electronBytecode, "Electron");

    expect(nodeResult.result).toBe(42);
    expect(nodeResult.multiply(3, 4)).toBe(12);
    expect(electronResult.result).toBe(42);
    expect(electronResult.multiply(3, 4)).toBe(12);
  });

  it("should document V8 version differences", async () => {
    // Get Node.js V8 version
    const nodeV8Version = process.versions.v8;
    console.log(`\nüîç V8 Version Information:`);
    console.log(`   Node.js ${process.version} uses V8 ${nodeV8Version}`);

    if (hasElectron && electronPath) {
      // Try to get Electron's V8 version
      const electronVersions = await new Promise<string>((resolve, reject) => {
        const child = spawn(electronPath!, ["--version"], {
          env: { ...process.env, ELECTRON_RUN_AS_NODE: "1" },
        });

        let output = "";
        child.stdout.on("data", (chunk) => {
          output += chunk.toString();
        });

        child.on("exit", () => resolve(output.trim()));
        child.on("error", reject);
      });

      console.log(`   Electron version: ${electronVersions}`);
      console.log(`\nüí° Key Insight:`);
      console.log(
        `   If V8 versions match, Node.js bytecode should work in Electron.`
      );
      console.log(
        `   If V8 versions differ, Electron-specific compilation may be needed.`
      );
    }
  });
});
