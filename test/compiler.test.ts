import { describe, it, expect, afterEach } from "vitest";
import vm from "node:vm";
import fs from "node:fs";
import path from "node:path";
import { compileToBytecode } from "../src/compiler";

describe("Bytecode Compiler", () => {
  const testFiles: string[] = [];

  afterEach(() => {
    // Clean up any generated bytecode files
    for (const file of testFiles) {
      if (fs.existsSync(file)) {
        fs.unlinkSync(file);
      }
    }
    testFiles.length = 0;
  });

  describe("compileToBytecode", () => {
    it("should compile simple JavaScript code to bytecode", () => {
      const testCode = `
"use strict";
const message = "Hello from bytecode!";
module.exports = { message };
`;

      const bytecode = compileToBytecode(testCode);

      expect(Buffer.isBuffer(bytecode)).toBe(true);
      expect(bytecode.length).toBeGreaterThan(0);
    });

    it("should wrap code in CommonJS module format", () => {
      const testCode = 'console.log("test");';
      const bytecode = compileToBytecode(testCode);

      // Bytecode should be generated from wrapped code
      // We can verify this by checking the source length stored in bytecode
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      // Wrapped code should be longer than original
      const wrappedLength =
        `(function (exports, require, module, __filename, __dirname) { ${testCode}\n});`
          .length;
      expect(length).toBe(wrappedLength);
    });

    it("should set flag hash header correctly", () => {
      const testCode = 'console.log("test");';
      const bytecode = compileToBytecode(testCode);

      const FLAG_HASH_OFFSET = 12;

      // Create a reference bytecode to compare flag hash
      const refScript = new vm.Script("", { produceCachedData: true });
      const refBytecode = refScript.cachedData!;

      // Flag hash should match the reference
      const bytecodeFlags = bytecode.subarray(
        FLAG_HASH_OFFSET,
        FLAG_HASH_OFFSET + 4
      );
      const refFlags = refBytecode.subarray(
        FLAG_HASH_OFFSET,
        FLAG_HASH_OFFSET + 4
      );

      expect(bytecodeFlags.equals(refFlags)).toBe(true);
    });
  });

  describe("Bytecode Loading and Execution", () => {
    it("should load and execute compiled bytecode", () => {
      const testCode = `
"use strict";
const greeting = "Hello from bytecode!";
console.log(greeting);
module.exports = { message: greeting };
`;

      // Compile to bytecode
      const bytecodeBuffer = compileToBytecode(testCode);

      // Get source length from bytecode
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecodeBuffer.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      // Create dummy code with matching length
      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      // Load bytecode
      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecodeBuffer,
      });

      expect(loadedScript.cachedDataRejected).toBe(false);

      // Execute bytecode
      const compiledWrapper = loadedScript.runInThisContext();
      expect(typeof compiledWrapper).toBe("function");

      // Create a mock module and execute
      const mockModule = { exports: {} as any };
      const mockRequire = require;

      compiledWrapper(
        mockModule.exports,
        mockRequire,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      expect(mockModule.exports).toHaveProperty("message");
      expect(mockModule.exports.message).toBe("Hello from bytecode!");
    });

    it("should handle bytecode written to and read from file", () => {
      const testCode = "module.exports = { value: 42 };";
      const testFile = path.join(__dirname, "test-temp.jsc");
      testFiles.push(testFile);

      // Compile and write to file
      const bytecode = compileToBytecode(testCode);
      fs.writeFileSync(testFile, bytecode);

      // Read from file
      const bytecodeBuffer = fs.readFileSync(testFile);
      expect(Buffer.isBuffer(bytecodeBuffer)).toBe(true);

      // Get source length
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecodeBuffer.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      // Create dummy code
      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      // Load and execute
      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecodeBuffer,
      });

      expect(loadedScript.cachedDataRejected).toBe(false);

      const compiledWrapper = loadedScript.runInThisContext();
      const mockModule = { exports: {} as any };

      compiledWrapper(
        mockModule.exports,
        require,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      expect(mockModule.exports.value).toBe(42);
    });

    it("should handle code with require statements", () => {
      const testCode = `
"use strict";
const path = require('path');
module.exports = { basename: path.basename('/test/file.js') };
`;

      const bytecode = compileToBytecode(testCode);
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecode,
      });

      const compiledWrapper = loadedScript.runInThisContext();
      const mockModule = { exports: {} as any };

      compiledWrapper(
        mockModule.exports,
        require,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      expect(mockModule.exports.basename).toBe("file.js");
    });

    it("should handle code with user-defined functions", () => {
      // This test validates that nested functions are properly compiled
      // Requires --no-lazy flag to be set BEFORE compilation
      // Without this flag, V8 lazily compiles nested functions, which causes
      // runtime errors when the function is called (it tries to parse dummy code)
      const testCode = `
"use strict";
function greet(name) {
  return "Hello, " + name + "!";
}
module.exports = { greet };
`;

      const bytecode = compileToBytecode(testCode);
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecode,
      });

      expect(loadedScript.cachedDataRejected).toBe(false);

      const compiledWrapper = loadedScript.runInThisContext();
      const mockModule = { exports: {} as any };

      // Execute the wrapper
      compiledWrapper(
        mockModule.exports,
        require,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      // Function should be defined and executable
      expect(mockModule.exports.greet).toBeDefined();
      expect(typeof mockModule.exports.greet).toBe("function");

      // CRITICAL TEST: Calling the function should work
      // This will fail without --no-lazy flag during compilation
      const result = mockModule.exports.greet("World");
      expect(result).toBe("Hello, World!");
    });

    it("should handle code with arrow functions", () => {
      // Arrow functions also require --no-lazy flag for proper compilation
      const testCode = `
"use strict";
const greet = (name) => "Hello, " + name + "!";
module.exports = { greet };
`;

      const bytecode = compileToBytecode(testCode);
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecode,
      });

      expect(loadedScript.cachedDataRejected).toBe(false);

      const compiledWrapper = loadedScript.runInThisContext();
      const mockModule = { exports: {} as any };

      compiledWrapper(
        mockModule.exports,
        require,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      expect(mockModule.exports.greet).toBeDefined();
      expect(typeof mockModule.exports.greet).toBe("function");

      // Test that arrow function executes correctly
      expect(mockModule.exports.greet("Test")).toBe("Hello, Test!");
    });

    it("should handle code with nested functions", () => {
      // Test deeply nested functions to ensure --no-lazy compiles everything
      const testCode = `
"use strict";
function outer() {
  function middle() {
    function inner() {
      return "nested";
    }
    return inner();
  }
  return middle();
}
module.exports = { outer };
`;

      const bytecode = compileToBytecode(testCode);
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecode,
      });

      expect(loadedScript.cachedDataRejected).toBe(false);

      const compiledWrapper = loadedScript.runInThisContext();
      const mockModule = { exports: {} as any };

      compiledWrapper(
        mockModule.exports,
        require,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      // All nested functions should execute correctly
      expect(mockModule.exports.outer()).toBe("nested");
    });

    it("should handle code with closures", () => {
      // Test that closures work correctly with bytecode
      const testCode = `
"use strict";
function createCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}
module.exports = { createCounter };
`;

      const bytecode = compileToBytecode(testCode);
      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );
      let length = 0;
      length |= sourceHash[3] << 24;
      length |= sourceHash[2] << 16;
      length |= sourceHash[1] << 8;
      length |= sourceHash[0];

      let dummyCode = "";
      if (length > 1) {
        dummyCode = '"' + "\u200b".repeat(length - 2) + '"';
      }

      const loadedScript = new vm.Script(dummyCode, {
        cachedData: bytecode,
      });

      const compiledWrapper = loadedScript.runInThisContext();
      const mockModule = { exports: {} as any };

      compiledWrapper(
        mockModule.exports,
        require,
        mockModule,
        __filename,
        __dirname,
        process,
        global
      );

      // Closure should maintain state correctly
      const counter = mockModule.exports.createCounter();
      expect(counter()).toBe(1);
      expect(counter()).toBe(2);
      expect(counter()).toBe(3);
    });
  });

  describe("Buffer Utilities", () => {
    it("should correctly convert 4-byte buffer to number", () => {
      const buffer = Buffer.from([0x12, 0x34, 0x56, 0x78]);

      let result = 0;
      result |= buffer[3] << 24;
      result |= buffer[2] << 16;
      result |= buffer[1] << 8;
      result |= buffer[0];

      expect(result).toBe(0x78563412);
    });

    it("should correctly extract source hash from bytecode", () => {
      const testCode = 'console.log("test");';
      const bytecode = compileToBytecode(testCode);

      const SOURCE_HASH_OFFSET = 8;
      const sourceHash = bytecode.subarray(
        SOURCE_HASH_OFFSET,
        SOURCE_HASH_OFFSET + 4
      );

      expect(sourceHash.length).toBe(4);
      expect(Buffer.isBuffer(sourceHash)).toBe(true);
    });
  });
});
